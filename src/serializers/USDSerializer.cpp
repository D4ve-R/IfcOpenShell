#ifdef WITH_USD

#include "USDSerializer.h"

#include "../ifcparse/utils.h"

#include "pxr/pxr.h"
#include "pxr/usd/usd/stage.h"
#include "pxr/usd/sdf/path.h"
#include "pxr/usd/usdGeom/xform.h"
#include "pxr/usd/usdGeom/xformOp.h"
#include "pxr/usd/usdGeom/mesh.h"
#include "pxr/usd/usdGeom/tokens.h"
#include "pxr/usd/usdGeom/scope.h"
#include "pxr/usd/usdLux/distantLight.h"
#include "pxr/usd/gf/vec3f.h"
#include "pxr/usd/gf/rotation.h"

#include <vector>
#include <string>
#include <sstream>


USDSerializer::USDSerializer(const std::string& filename, const SerializerSettings& settings, bool read_only)
	: WriteOnlyGeometrySerializer(settings)
	, filename_(filename)
	, settings_(settings)
{
  // create a new stage
  stage_ = pxr::UsdStage::CreateNew(filename + ".usda");
  if( !settings().get(SerializerSettings::USE_Y_UP) )
    stage_->SetDefaultPrim(pxr::UsdGeomXform::Define(stage_, pxr::SdfPath("/"), pxr::UsdGeomTokens->z));
  else
    stage_->SetDefaultPrim(pxr::UsdGeomXform::Define(stage_, pxr::SdfPath("/"), pxr::UsdGeomTokens->y));
  // create root xform prim 'World'
  pxr::UsdGeomXform::Define(stage_, pxr::SdfPath("/World"));
  pxr::UsdGeomScope::Define(stage_, pxr::SdfPath("/Looks"));
  createLighting();
  ready_ = true;
}

USDSerializer::~USDSerializer() {
	
}

void USDSerializer::writeLighting() {
  // create a distant light
  const std::string& light_path = "/World/defaultLight";
  pxr::UsdLuxDistantLight::Define(stage_, pxr::SdfPath(light_path));
  // set the light's orientation
  pxr::UsdGeomXform xform(stage_->GetPrimAtPath(pxr::SdfPath(light_path)));
  pxr::GfVec3f light_direction(0.0f, 0.0f, -1.0f);
  xform.AddRotateOp(pxr::UsdGeomXformOp::PrecisionFloat, pxr::UsdGeomXformOp::TypeRotateXYZ).Set(pxr::GfRotation(pxr::GfVec3f(0.0f, 1.0f, 0.0f), light_direction).GetQuaternion());
  // set the light's color
  pxr::UsdLuxDistantLight light(stage_->GetPrimAtPath(pxr::SdfPath(light_path)));
  light.CreateIntensityAttr().Set(1000.0f);
  light.CreateColorAttr().Set(pxr::GfVec3f(1.0f, 1.0f, 1.0f));
}

bool USDSerializer::ready() {
	return ready_;
}

void USDSerializer::writeHeader() {
  std::stringstream ss;
  ss << "File generated by IfcOpenShell " << IFCOPENSHELL_VERSION;
  stage_->SetMetadata("comment", ss.str()); 
}

void USDSerializer::write(const IfcGeom::TriangulationElement* o) {
	if ( o->geometry().material_ids().empty() )
		return;
  
  std:sstringstream ss("/World/");
  ss << o->geometry().id();
  pxr::UsdGeomMesh::Define(stage_, pxr::SdfPath(ss.str()));
  const IfcGeom::Representation::Triangulation& mesh = o->geometry();
  const std::vector<double>& m = o->transformation().matrix().data();

  const int vcount = (int)mesh.verts().size() / 3;
  for ( std::vector<double>::const_iterator it = mesh.verts().begin(); it != mesh.verts().end(); ) {
    const double x = *(it++);
    const double y = *(it++);
    const double z = *(it++);
		
		
	}

}

void USDSerializer::finalize() {
  stage_->GetRootLayer()->Save();
}

#endif // WITH_USD